前言 
前端开发者们每天都在接触 xxx install，前端生态如此繁荣，包管理工具功不可没。最早的包管理工具是 npm（Node Package Manager   pkgmakeinst/pm）。2010 年前端的包管理先驱 npm 正式发布，并被 node 支持，有着功不可没的贡献，同时创造出了比世界上人类已知黑洞更可怕的Object。经典物理学理论总是脱离不了对于时间、空间的探索，有黑洞，也必然有虫洞...

[](node_modules黑洞)

## 1、历史的车轮
作为一个与时俱进的前端开发者，每天都会接触 xxx install，包管理器是必不可少的工具。在开始之前我们先来回顾一下前端包管理的发展的简单脉络，去感受一下历史的红尘。

[](包管理发展历史)

2010年之前：前端依赖项需要手动下载并，保存到存储库中
2010年1月： npm第一个版本正式发布；
2015年5月：npm发布v3.x 版本；
2016年1月：pnpm 提交诞生并发布第一个版本；
2016年： yarn发布第一个v0.x 正式版本；
2016年： npm 发布v4.x 版本；
2017年： npm 发布v5.x 版本；
2018年： npm 发布v6.x 版本；
2020年：yarn 发布正式版本 2；
2020年：npm 发布v7.x 版本；
2021年： yarn  发布正式版本 3；
2021年： pnpm发布6.0 版本；

## 2、npm是什么

 刚开始 npm 的设计非常的简单：有一个标准的包管理器供大家下载和查阅，将开发人员从那个“网上下载资源，在手动解压添加近项目”的年代中解放出来。
### 2.1 npm v2.x 黑洞终结者

最初版本的 npm v1.x 、 v2.x   使用了很简单嵌套结构来进行版本管理，第一次使前端开发者从手动管理依赖的开发流程中解放了双手。但是真的就一劳永逸了吗？

[](项目依赖过大)
问题1： 为什么我的项目占用存储体积这么大，说好的复用呢？
问题2：为什么我的window电脑右键删除失效了呢？
问题3：为什么同一个依赖包同一个版本安装了这么多次呢？

npm v2.x   会安装每一个包所依赖的所有依赖项。如果我们有这么一个项目，它依赖项目A，项目A依赖项目B，项目B依赖项目C，那么依赖树将如下所示：
```
node_modules 
- package-A 
  -- node_modules 
     --- package-B 
      ----- node_modules 
          ------ package-C 
               -------- some-really-really-really-long-file-name-in-package-c.js
```
基于嵌套结构的依赖Unix的操作系统来说只不过是一个小烦恼，但对于Windows来说却是个破坏性的东西，因为有很多程序无法处理超过260个字符的文件路径名。
子子孙孙无穷尽也..........
### 2.2  npm v3.x   的扁平化 大家真的平等吗？
     看到npm  v2.x 带来的好处的同时，我们也看清了它磁盘杀手的真面目，那么必然会有时代的进步者试图来填补这个黑洞， 既然要换取空间，那最简单的办法就是牺牲时间了。
       为了将嵌套的依赖尽量打平，避免过深的依赖树和包冗余，npm v3.x. 首先遍历所有的项目依赖关系，然后再决定如何生成扁平的node_modules目录结构。npm必须为所有使用到的模块构建一个完整的依赖关系树，这是一个耗时的操作，是npm安装速度慢很重要的一个原因。npm v3 将子依赖「提升」(hoist)，采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。但是项目的依赖们，真的平等了吗？

[](npmv3.x）

幽灵依赖：项目中依赖的依赖也会因扁平化方案，提升到node_modules根目录；
双生不确定性： 根目录的依赖包版本会随着依赖的顺序不同而不同；
依赖分身  Doppelgangers： node_modules这种 数据结构会被迫安装同一个包相同版本的 的 两份拷贝；
为什么我的项目开发、测试、上线一切正常，突然就线上bug了呢？

### 2.3 npm 5.x  统筹规划，动态管制，静默别动
   扁平化的管理真的无效吗，引发这么多新的问题，既然npm采用语义化的版本号 semver 进行控制，是不是我们可以再改进一下，分级统筹管理，严格控制依赖，就可以解决了.
     但，现实情况是总有些包开发人员不会严格遵循npm 的版本语义化规范。
[](npm5.x 版本锁定)

缓存机制：npm cache
版本锁定： shrinkwrap.json 、package-lock.json
理想很丰满，现实却从来不会让你失望！

## 3、yarn  新一代包管理工具？
   为了弥补 npm 的一些缺陷， Facebook、Google、Exponent 和 Tilde 联合推出了一个新的 JS 包管理工具 在 2016 年推出的新一代包管理工具yarn  ，不仅具有比npm更简洁的输出, 而且具有版本锁定，安装失败自动重试，但最终要的还是安装速度的提升。
### 3.1  yarn v1.x  

使用了并行下载（相比而言 npm 是串行依次下载的），提升了下载速度。

[](yarn 速度快？)

嗯，速度真的很快 ???

### 3.2 yarn 2.x 
    202年 发布的yarn v2.x版本，还有一个神奇的 feature：PnP （Plug and Play）安装模式，用一个 .pnp.js 文件代替整个 node_modules 文件夹，这已经超出nodejs的国界了...
   由于这个惊人的模式太反常规了，存在兼容性问题，一些包在 pnp 模式下出现依赖错误，目前接受度不高。

[](pnpm)

## 4、pnpm（performant npm）  时空中的虫洞？
    历史证明，没有创新就没有进步，物质世界不是除了层层依赖的树状结构，就只有散落尘埃的沙子，如果有黑洞那一定存在虫洞。
   pnpm 的作者Zoltan Kochan发现 yarn 并没有打算去解决上述的这些问题，于是另起炉灶，写了全新的包管理器，开创了一套新的依赖管理机制


在引用项目 node_modules 的依赖时，pnpm采用内容寻址存储 CAS 机制，通过硬链接与符号链接在全局 store 中找到这个文件。为了实现此过程，node_modules 下会多出 .pnpm 目录，而且是非扁平化结构。
> 硬链接 Hard link：硬链接可以理解为源文件的副本，项目里安装的其实是副本，它使得用户可以通过路径引用查找到全局 store 中的源文件，而且这个副本根本不占任何空间。同时，pnpm 会在全局 store 里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖，大大地节省了磁盘空间。
符号链接 
> Symbolic link：也叫软连接，可以理解为快捷方式，pnpm 可以通过它找到对应磁盘目录下的依赖地址。

## 5、pnpm 是前端包管理的银弹吗？


pnpm是终结者吗？可能是，但肯定不是。
正如Sebastian在Twitter上指出的那样，他最初是打算在yarn中使用符号链接的，最终 Sebastian还是放弃了。
pnpm 创建的 node_modules 依赖软链接，在不支持软链接的环境中，无法使用，比如 Electron 应用；
非扁平化破坏性的结构和必须使用自身锁文件pnpm-lock.yaml，都给迁移带来了写成本；
不同应用的依赖是硬链接到同一份文件上，如果在调试时修改了某个依赖的文件，可能无意间影响了其他项目

参考文章：
1、[https://zhuanlan.zhihu.com/p/496454042](pnpm 是凭什么对 npm 和 yarn 降维打击的)

2、[https://zhuanlan.zhihu.com/p/496454042](关于现代包管理器的深度思考)

3、[https://juejin.cn/post/7127295203177676837](现代包管理器的进化史)

4、[https://nodejs.org/zh-cn/download/releases/] (nodejs 与 npm 版本查询)

